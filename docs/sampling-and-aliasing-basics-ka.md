# სემპლირების სიჩქარე და ალიასინგი – დამწყებისთვის

ეს არის ჩემი პირადი ჩანაწერები იმის გასაგებად, როგორ მუშაობს
სემპლირების სიჩქარე (sampling rate), სიგნალის ზოლი (bandwidth)
და ალიასინგი SDR-ში. მიზანია, მომავალში HackRF One-თან მუშაობისას
სწორად შევარჩიო სემპლირების სიჩქარე და არ გავიკვირვო, რატომ
ჩნდება სიგნალი „შეცდომით“ სხვაგან სპექტრში.

---

## 1. რა არის სემპლირება?

ანალოგური RF სიგნალი გარდაიქმნება ციფრულად, როცა მას პერიოდულად
„ვწყვეტთ“ და ვიღებთ ნიმუშებს:

> sample, sample, sample, sample, …

**სემპლირების სიჩქარე** (Fs) გვიჩვენებს, წამში რამდენ ნიმუშს ვიღებთ.

მაგალითად:

- Fs = 1 000 000 ნიმუში/წმ (1 MS/s)
- Fs = 2 000 000 ნიმუში/წმ (2 MS/s)
- Fs = 10 000 000 ნიმუში/წმ (10 MS/s)

SDR-ში თითო ნიმუში არის კომპლექსური მნიშვნელობა: I + jQ.

---

## 2. ნიქვისტის კრიტერიუმი: რამდენად სწრაფად უნდა ვსემპლირებდეთ?

ძირითადი წესი:

> რომ სიგნალი სწორად წარმოვადგინოთ, გვჭირდება  
> **Fs ≥ 2 × B**

სადაც **B** – სიგნალის ზოლი (bandwidth) არის.

მაგალითები:

- თუ სიგნალის ზოლი ~100 kHz-ია → Fs მინიმუმ ≈ 200 kS/s.  
- თუ სიგნალის ზოლი ~2 MHz-ია → Fs მინიმუმ ≈ 4 MS/s.

პრაქტიკაში ხშირად ვირჩევთ ოდნავ უფრო დიდ სემპლირების სიჩქარეს,
ვიდრე ზუსტად 2×B, რომ ფილტრაცია გამარტივდეს და „საცავი“ სივრცე გვქონდეს.

---

## 3. რა არის ალიასინგი?

თუ **ყველაფერს ძალიან ნელა ვსემპლირებთ**, სხვადასხვა სიხშირეები
ერთმანეთზე „იღუნება“ და ციფრულ სამყაროში ერთმანეთს ემთხვევა.
ეს ეფექტი נק叫ე **ალიასინგი**.

ანალოგია:

- წარმოვიდგინოთ მბრუნავი ბორბალი, რომელსაც დაბალი FPS-ის კამერით ვიღებთ.
- ზოგჯერ ბორბალი ჰგვანდება, თითქოს ნელა ან უკუღმა ბრუნავს.
- კამერა **ალიასინგს** აკეთებს – რეალური მოძრაობა სხვანაირად ჩანს.

SDR-ში:

- Fs/2-ზე **ზედა** სიხშირეები „იკეცება“ [−Fs/2, +Fs/2] ინტერვალში.  
- შედეგად, მაღალი სიხშირის სიგნალი სპექტრში შეიძლება სულ სხვა
  ადგილზე გამოჩნდეს.

იდეა: სპექტრი ყოველ Fs ჰერცში მეორდება, SDR კი ჩვენ გვაჩვენებს მხოლოდ
ერთ „ფანჯარას“ ამ განმეორებადი სპექტრიდან.

---

## 4. საბაზისო ზოლი და ცენტრალური სიხშირე

SDR-ის (მაგალითად HackRF-ის) გამოყენებისას ვირჩევთ:

1. **ცენტრალურ სიხშირეს** (F_center) – სად „ვამაგრებთ“ ტიუნერს RF სპექტრში.  
2. **სემპლირების სიჩქარეს** (Fs) – რამდენად ფართოა საბაზისო ფანჯარა.

საბაზისო ზოლი დაახლოებით ასეთ დიაპაზონს ფარავს:

> −Fs/2-დან +Fs/2-მდე 0 Hz-ის ირგვლივ

თუ ტიუნერს F_center-ზე ვაყენებთ, მაშინ რეალური RF დიაპაზონი, რასაც ვხედავთ,
დაახლოებით ასეთია:

> [F_center − Fs/2, F_center + Fs/2]

ამ დიაპაზონს გარეთ მყოფი სიხშირეები ან საერთოდ არ ხვდება ჩანაწერში,
ან (თუ ფილტრაცია არასაკმარისია) შეიძლება ფანჯარაში **ალიასინგით** შემოიტანოს.

გამოდის:

- მაღალი Fs → **ფართო ფანჯარა**, მეტ სპექტრს ვხედავთ.  
- დაბალი Fs → **ვიწრო ფანჯარა**, ნაკლები სპექტრი, მაგრამ ნაკლები მონაცემი.

---

## 5. რატომ უნდა გავფილტროთ დაქვეითებამდე (decimation)?

ხშირად გვინდა, რომ სემპლირების სიჩქარე **დავაპატარავოთ** დამუშავების
გასამარტივებლად, მაგალითად:

- დავიწყოთ Fs = 10 MS/s  
- შემდეგ დავწიოთ Fs = 1 MS/s-მდე (decimation)

ამის გაკეთება **უბრალოდ ნიმუშების გადაგდებით** არ შეიძლება.

ნაბიჯები:

1. **დაბალგამტარი ფილტრი** (low-pass), რომ მხოლოდ იმ ზოლს დავიტოვოთ,
   რომელიც გვაინტერესებს.  
2. შემდეგ **დექსიმაცია** – მაგალითად, ყოველი N-ე ნიმუშის დატოვება.

თუ ფილტრს არ გამოვიყენებთ, მაღალი სიხშირის კომპონენტები ახალი, უფრო ვიწრო
[−Fs_new/2, +Fs_new/2] დიაპაზონში **ალიასინგით** შემოცვივდება.

წესი:

> ჯერ ვფილტრავთ ისე, რომ სიგნალი დაეტიოს ახალ ზოლში,  
> მერე ვაპატარავებთ სემპლირების სიჩქარეს (decimate).

---

## 6. სემპლირების სიჩქარის არჩევა პრაქტიკაში

HackRF-თან ექსპერიმენტებისთვის ტიპიური ვარიანტები:

- **ვიწრო სიგნალი (~100 kHz)**  
  напр. narrow FM ან ზოგიერთი ციფრული რეჟიმი  
  → Fs ≈ 500 kS/s – 1 MS/s.

- **FM მაუწყებლობა (~200 kHz + დაცვა)**  
  → Fs = 1–2 MS/s ხშირად საკმარისია.

- **ADS-B 1090 MHz-ზე**  
  პულსები საკმაოდ სწრაფია, ამიტომ ხშირად იყენებენ 2–4 MS/s (ან მეტს),
  შემდეგ კი ფილტრაციის შემდეგ ამცირებენ.

კომპრომისი:

- მაღალი Fs:
  - + მეტ ზოლს ვხედავთ  
  - + ვფარავთ სწრაფ ცვლილებებს  
  - − დიდი ფაილები, მეტი CPU

- დაბალი Fs:
  - + დამუშავება იოლია  
  - − ვხედავთ ნაკლებ ზოლს, არასწორი არჩევისას – ალიასინგის რისკი

---

## 7. როგორ უკავშირდება ეს ჩემს მაგალითურ სკრიპტებს

ამ პროექტში ხშირად ვიყენებ:

> Fs = 2 000 000 (2 MS/s)

`generate_test_tone.py`-ისა და ტესტური გრაფიკებისთვის:

- Fs = 2 MS/s გვაძლევს საბაზისო დიაპაზონს დაახლოებით:
  −1 MHz-დან +1 MHz-მდე.

თუ ორ ტონს ამ დიაპაზონში დავაყენებ, სპექტრში ორი პიკის სახით გამოჩნდება.

ექსპერიმენტები, რომლებიც მინდა later გავაკეთო:

- ტონის გენერაცია Fs/2-ის მახლობლად და მისი ქცევის დაკვირვება.  
- ტონის გენერაცია Fs/2-ზე ზემოთ და ალიასინგის ნახვა სპექტრში.  
- რეალური სიგნალის ჩაწერა „ძალიან დაბალი“ Fs-ით და
  შედარება იგივე სიგნალთან, რომელიც უფრო მაღალი Fs-ით ჩაიწერა.

ასეთი პატარა ექსპერიმენტები ალიასინგს უფრო „ცოცხალ“ ფენომენად აქცევს,
არა მხოლოდ ფორმულად.

---

## 8. შეჯამება

- სემპლირების სიჩქარე (Fs) გვიჩვენებს, წამში რამდენ ნიმუშს ვიღებთ.  
- ნიქვისტის წესი ამბობს: Fs უნდა იყოს **მინიმუმ ორჯერ მეტი**, ვიდრე
  სიგნალის ზოლი.  
- თუ Fs ძალიან მცირეა, სხვადასხვა სიხშირეები **ალიასინგით** ერთმანეთს
  ემთხვევა და სპექტრში არასწორად ჩნდება.  
- SDR-ში ვირჩევთ ცენტრალურ სიხშირეს და ვიღებთ საბაზისო ფანჯარას
  [F_center − Fs/2, F_center + Fs/2].  
- სემპლირების სიჩქარის შემცირებისას აუცილებელია ჯერ **ფილტრი**, შემდეგ
  **დექსიმაცია**.  
- ამ იდეების ცოდნა გვეხმარება, სწორად ავირჩიოთ Fs და არ დავიბნეთ,
  როცა სპექტრში უცნაურ შედეგებს ვხედავთ.

ეს შენიშვნები ჩემი სწავლებისთვისაა დაწერილი და მომავალში
მიემაგრება HackRF One-თან უფრო რეალურ ექსპერიმენტებს.
